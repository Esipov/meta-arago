From 35d7ab5678ce2287b681cb2735ec4307f3f83a6b Mon Sep 17 00:00:00 2001
From: Ido Yariv <ido@wizery.com>
Date: Tue, 13 Dec 2011 23:28:12 +0200
Subject: [PATCH 2/2] wl12xx: Decrease number of TX transactions

On weak platforms, it is crucial to keep the number of SDIO transactions
to a bare minimum. It is probably more important to keep CPU utilization
low, than to handle FW events asap.

In order to decrease the number of TX transactions, don't schedule tx
work right away for every outgoing packet. Instead, try to wait for a
short period before scheduling tx work if there aren't enough pending
packets.

In addition, increase the TX pacing timeout, so the FW will have enough
free memory blocks for larger transfers.
---
 drivers/net/wireless/wl12xx/main.c   |   39 ++++++++++++++++++++++++++++++---
 drivers/net/wireless/wl12xx/wl12xx.h |    3 ++
 2 files changed, 38 insertions(+), 4 deletions(-)

diff --git a/drivers/net/wireless/wl12xx/main.c b/drivers/net/wireless/wl12xx/main.c
index f90b96a..e65eb5d 100644
--- a/drivers/net/wireless/wl12xx/main.c
+++ b/drivers/net/wireless/wl12xx/main.c
@@ -211,8 +211,8 @@ static struct conf_drv_settings default_conf = {
			},
		},
		.frag_threshold              = IEEE80211_MAX_FRAG_THRESHOLD,
-		.tx_compl_timeout            = 700,
-		.tx_compl_threshold          = 4,
+		.tx_compl_timeout            = 1500,
+		.tx_compl_threshold          = 6,
		.basic_rate                  = CONF_HW_BIT_RATE_1MBPS,
		.basic_rate_5                = CONF_HW_BIT_RATE_6MBPS,
		.tmpl_short_retry_limit      = 10,
@@ -994,6 +994,8 @@ static irqreturn_t wl1271_irq(int irq, void *cookie)
			spin_lock_irqsave(&wl->wl_lock, flags);
			if (!test_bit(WL1271_FLAG_FW_TX_BUSY, &wl->flags) &&
			    wl1271_tx_total_queue_count(wl) > 0) {
+				hrtimer_try_to_cancel(&wl->tx_timer);
+				clear_bit(WL1271_FLAG_TX_TIMER_SET, &wl->flags);
				spin_unlock_irqrestore(&wl->wl_lock, flags);
				/*
				 * In order to avoid starvation of the TX path,
@@ -1536,6 +1538,9 @@ out:
	return ret;
 }

+#define TX_PACKETS_THRESHOLD	6
+#define TX_WORK_DELAY_NS	(1500 * 1000)
+
 static void wl1271_op_tx(struct ieee80211_hw *hw, struct sk_buff *skb)
 {
	struct wl1271 *wl = hw->priv;
@@ -1584,14 +1589,37 @@ static void wl1271_op_tx(struct ieee80211_hw *hw, struct sk_buff *skb)
	 * before that, the tx_work will not be initialized!
	 */

-	if (!test_bit(WL1271_FLAG_FW_TX_BUSY, &wl->flags) &&
-	    !test_bit(WL1271_FLAG_TX_PENDING, &wl->flags))
+	if (test_bit(WL1271_FLAG_FW_TX_BUSY, &wl->flags) ||
+	    test_bit(WL1271_FLAG_TX_PENDING, &wl->flags))
+		goto out;
+
+	if (wl1271_tx_total_queue_count(wl) < TX_PACKETS_THRESHOLD) {
+		if (!test_and_set_bit(WL1271_FLAG_TX_TIMER_SET, &wl->flags))
+			hrtimer_start(&wl->tx_timer,
+				      ktime_set(0, TX_WORK_DELAY_NS),
+				      HRTIMER_MODE_REL);
+	} else {
+		hrtimer_try_to_cancel(&wl->tx_timer);
+		clear_bit(WL1271_FLAG_TX_TIMER_SET, &wl->flags);
		ieee80211_queue_work(wl->hw, &wl->tx_work);
+	}

 out:
	spin_unlock_irqrestore(&wl->wl_lock, flags);
 }

+enum hrtimer_restart wl12xx_tx_timer(struct hrtimer *timer)
+{
+	struct wl1271 *wl = container_of(timer, struct wl1271, tx_timer);
+	unsigned long flags;
+
+	spin_lock_irqsave(&wl->wl_lock, flags);
+	clear_bit(WL1271_FLAG_TX_TIMER_SET, &wl->flags);
+	ieee80211_queue_work(wl->hw, &wl->tx_work);
+	spin_unlock_irqrestore(&wl->wl_lock, flags);
+	return HRTIMER_NORESTART;
+}
+
 int wl1271_tx_dummy_packet(struct wl1271 *wl)
 {
	unsigned long flags;
@@ -2162,6 +2190,7 @@ static void wl1271_op_stop(struct ieee80211_hw *hw)
	 * functions don't perform further work.
	 */
	wl->state = WL1271_STATE_OFF;
+	hrtimer_cancel(&wl->tx_timer);
	mutex_unlock(&wl->mutex);

	mutex_lock(&wl_list_mutex);
@@ -5835,6 +5864,8 @@ static struct ieee80211_hw *wl1271_alloc_hw(void)
	wl->active_sta_count = 0;
	wl->fwlog_size = 0;
	init_waitqueue_head(&wl->fwlog_waitq);
+	hrtimer_init(&wl->tx_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	wl->tx_timer.function = wl12xx_tx_timer;

	/* The system link is always allocated */
	__set_bit(WL12XX_SYSTEM_HLID, wl->links_map);
diff --git a/drivers/net/wireless/wl12xx/wl12xx.h b/drivers/net/wireless/wl12xx/wl12xx.h
index 269fadf..437526f 100644
--- a/drivers/net/wireless/wl12xx/wl12xx.h
+++ b/drivers/net/wireless/wl12xx/wl12xx.h
@@ -265,6 +265,7 @@ enum wl12xx_flags {
	WL1271_FLAG_RECOVERY_IN_PROGRESS,
	WL1271_FLAG_VIF_CHANGE_IN_PROGRESS,
	WL1271_FLAG_INTENDED_FW_RECOVERY,
+	WL1271_FLAG_TX_TIMER_SET,
 };

 enum wl12xx_vif_flags {
@@ -552,6 +553,8 @@ struct wl1271 {
	struct list_head peers_list;

	bool watchdog_recovery;
+
+	struct hrtimer tx_timer;
 };

 struct wl1271_station {
--
1.7.7.6
